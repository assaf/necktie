I use Necktie to setup and upgrade multiple servers. 


== Dress to impress

Necktie runs a set of scripts (or configuration tasks) that can create and edit
files, install and setup services, mount volumes, and basically anything you
can script with Ruby and a shell.

To use Necktie:
- Write your Necktie tasks using Ruby
- Include support files (config, binaries, etc)
- git push
- cap necktie

I use it to:

- gem install, apt-get
- Configure Nginx, install and setup Unicorn
- Change memcached configuration from default
- Setup MySQL to use a mounted (EBS) volume
- Install and update cron scripts


== Tasking

Necktie is based on Rake, so if you know Rake you already know most of Necktie.
At the base of your Necktie project there's a file called necktie (or Necktie,
or necktie.rb), with a list of task. For example:

  file "/var/myapp" do
    append "/etc/fstab", "\n/mnt/myapp /var/myapp none bind" unless read("/etc/fstab")["/mnt/myapp"]
    mkdir_p "/var/myapp/"
    sh "mount /var/myapp"
  end

  task :rubygems do
    FileList["gems/*.gem"].each do |gem|
      install_gem gem
    end
  end

  task :nginx do
    rm_rf "/etc/nginx/sites-enabled/*"
    cp "etc/nginx/unicorn.conf", "/etc/nginx/sites-available/"
    ln_sf "/etc/nginx/sites-available/unicorn.conf", "/etc/nginx/sites-enabled/"
    services.start "nginx"
  end

  task :unicorn=>[:rubygems] do
    cp "etc/init.d/unicorn", "/etc/init.d/"
    chmod 0750, "/etc/init.d/unicorn"
  end

  task :app=>["/var/myapp", :nginx, :unicorn]

You then run the app task, which runs all the dependencies necessary to setup
your application directory, system gems, Nginx and Unicorn configuration. Ready
for deployment.

If you changed one of the configuration files, you can run Necktie again: it
will pull updates from the Git repository and run these tasks with the new
configuration files.

Note: The nginx and unicorn files will run every time you run the app task, so
you can use them to push out new configuration.  In contrast, the /var/myapp
directory is mounted by a file task that will only run once (if the directory
doesn't exist).


== cap necktie

I use Capistrano to setup new instances and upgrade existing ones.  I then run
deploy:cold on the new instances, or deploy to upgrade running instances.

The Capistrano tasks looks something like this (see also:
extra/capistrano/necktie.rb):

  # Copy Gem over so not depending on gem server being online, and all servers get
  # to use the same version of Necktie.
  gem_spec = Gem::SourceIndex.from_installed_gems.find_name("necktie").last
  gem_file = File.join(Gem.dir, "cache", spec.file_name)
  upload gem_file, File.basename(gem_file), :via=>:scp
  sudo "gem install #{File.basename(gem_file)}"
  # Run Necktie as sudo.
  sudo "necktie #{necktie_url} #{ENV["ROLES"].to_s.gsub(',', ' ')}"

To setup a new server:

  cap necktie HOSTS=ec2-75-101-239-12.compute-1.amazonaws.com

To upgrade instances:

  git push && cap necktie


== Feel the rush

Necktie includes Rush, so you can write tasks like this:

  unless processes.find { |p| p.cmdline[/memcached\s.*-l\s0.0.0.0/] }
    box["/etc/memcached.conf"].replace_contents! /^-l 127.0.0.1/, "-l 0.0.0.0"
    Services.start "memcached"
  end

You can learn more about Rush here: http://rush.heroku.com

Of course, there's also FileUtils, system and sh, so you can just:

  cp "etc/init.d/unicorn", "/etc/init.d"
  chmod 0755, "/etc/init.d/unicorn"
  sh "service start unicorn"

Note: The current directory (launch_dir and Dir.pwd) is the root directory
of your Necktie repository. You can use relative paths to access files from your
Necktie repository.


== Role play

If you have different setups, split them into roles and give each role its own
head task. You can then run Necktie for one or several roles, in the order they
are listed on the command line.

For example:

  task :app=>["rubygems", "nginx", "unicorn", "/var/myapp"]
  task :db=>["mount", "master", "backup"]


I recommend using the same roles for Necktie and Capistrano, then you can:

  cap necktie ROLES=app,db

Note: Command line arguments are either task names (run in order), or
name=value pairs that set environment variables (e.g.  RAILS_ENV=production).


== gem install

You can use install_gem in one of two ways. You can pass it a gem name and
(optional, but highly recommended) version requirement. For example:

  install_gem "unicorn", "~= 0.93"

You can store the gem file in your Necktie repository and install it from there:

  install_gem "gems/unicorn-0.93.3.gem"

I prefer the later, so I'm not affected when gem sources go offline just as I
decide to run my Necktie tasks.

Since install_gem will only install the same gem/version once, a run-always
rubygems.rb task is all you need:

  launch_dir["gems/*.gem"].each do |gem|
    install_gem gem.to_s
  end


== License

Necktie, copyright (C) 2009 Assaf Arkin, released under the "Use for good, not
evil" license (http://www.json.org/license.html)

Includes Rake, created by Jim Weirich and released under the MIT license
http://rake.rubyforge.org/ http://github.com/jimweirich/rake

Includes Rush, created by Adam Wiggins and released under the MIT License
http://rush.heroku.com http://github.com/adamwiggins/rush

Includes Session, created by Ara T. Howard and released under the Ruby License
http://raa.ruby-lang.org/project/session
http://www.codeforpeople.com/lib/ruby/session
